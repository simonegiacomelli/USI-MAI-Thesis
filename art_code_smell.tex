\section{Code Smells and Antipatterns}
\textbf{copy\&paste}
Several techniques have been proposed in the literature to detect code smell instances affecting code components, and all of these take their cue from the suggestions provided by four well-known books: [29], [16], [86], [66].

\subsection{Four inspirational books description}
\textbf{copy\&paste}
\\
%smell-book-a
\textbf{Webster [86] - todo}
The first one, by Webster \cite{webster1995pitfalls} defines common pitfalls in Object Oriented Development, going from the project management down to the implementation.
\\
\\
%smell-book-b
\textbf{Riel [66] - todo}
Riel [66] describes more than 60 guidelines to rate the integrity of a software design
\\
\\
%smell-book-c
\textbf{Fowler [29] - todo}
The third one, by Fowler [29], describes 22 code smells describing for each of them the refactoring actions to take. 
\\
\\
%smell-book-d
\textbf{Brown et al. [16] - todo}
Brown et al. [16] define 40 code antipatterns of different nature (i.e., architectural, managerial, and in source code), together with heuristics to detect them.
\\
\\
\subsection{Last decade proposed approaches}
From these starting points, in the last decade several approaches have been proposed to detect design flaws in source code - todo fix copy\&paste
\\
\\
%smell-1
\textbf{Travassos et al. \cite{travassos1999detecting} }
Travassos et al. created a set of techniques for manually identifying defects in order to improve software quality. These practices help individuals to read object oriented code and assess, through a predefined taxonomy, if some problem is present. The authors conducted an empirical study on these techniques and report their feasibility.
\\
\\
%smell-2
\textbf{van Emden and Moonen [83] todo, fix copy\&paste }
van Emden and Moonen [83] presented jCOSMO, a code smell browser that visualizes the detected smells in the source code. In particular, they focus their attention on two Java programming smells, known as instanceof and typecast. The first occurs when there are too many instanceof operators in the same block of code that make the source code difficult to read and understand. The typecast smell appears instead when an object is explicitly converted from one class type into another, possibly performing illegal casting which results in a runtime error.
\\
\\
%smell-3
\textbf{Simon et al. [] todo, fix copy\&paste }
Simon et al. [72] provided a metric-based visualization tool able to discover design defects repre- senting refactoring opportunities. For example, a Blob is detected if different sets of cohesive attributes and methods are present inside a class. In other words, a Blob is identified when there is the possibility to ap- ply Extract Class refactoring.
\\
\\
%smell-4
\textbf{Marinescu [50] todo, fix copy\&paste }
Marinescu [50] proposed a metric-based mechanism to capture deviations from good design principles and heuristics, called “detection strategies”. Such strategies are based on the identifica- tion of symptoms characterizing a particular smell and metrics for measuring such symptoms. Then, thresholds on these metrics are defined in order to define the rules
\\
\\
%smell-5
\textbf{Lanza and Marinescu  [44] todo, fix copy\&paste }
Lanza and Marinescu [44] showed how to exploit quality metrics to identify “disharmony patterns” in code by defining a set of thresholds based on the measurement of the exploited metrics in real software systems. Their de- tection strategies are formulated in four steps. In the first step, the symptoms characterizing a smell are defined. In the second step, a proper set of metrics measuring these symptoms is identified. Having this information, the next step is to define thresholds to classify the class as affected (or not) by the defined symptoms. Finally, AND/OR operators are used to correlate the symptoms, leading to the final rules for detecting the smells.
\\
\\
%smell-6
\textbf{Munro [53] todo, fix copy\&paste }
Munro [53] presented a metric-based detection tech- nique able to identify instances of two smells, i.e., Lazy Class and Temporary Field, in the source code. A set of thresholds is applied to some structural metrics able to capture those smells. In the case of Lazy Class, the metrics used for the identification are Number of Meth- ods (NOM), LOC, Weighted Methods per Class (WMC), and Coupling Between Objects (CBO).
\\
\\
%smell-7
\textbf{Moha et al. [51] todo, fix copy\&paste }
Moha et al. [51] introduced DECOR, a technique for specifying and de- tecting code and design smells. DECOR uses a Domain- Specific Language (DSL) for specifying smells using high-level abstractions. Four design smells are identified by DECOR, namely Blob, Swiss Army Knife, Functional De- composition, and Spaghetti Code.
\\
\\
%smell-8
\textbf{Tsantalis and Chatzigeorgiou [79] todo, fix copy\&paste }
Tsantalis and Chatzigeorgiou [79] presented JDeodor- ant, a tool able to detect instances of Feature Envy smells with the aim of suggesting move method refactoring op- portunities. For each method of the system, JDeodorant forms a set of candidate target classes where a method should be moved. This set is obtained by examining the entities (i.e., attributes and methods) that a method accesses from the other classes. In its current version JDeodorant8 is also able to detect other three code smells (i.e., State Checking, Long Method, and God Classes), as well as opportunities for refactoring code clones.
\\
\\
%smell-9
\textbf{Ligu et al. [47] todo, fix copy\&paste }
Ligu et al. [47] introduced the identification of Refused Bequest code smell using a combination of static source code analysis and dynamic unit test execution. Their approach aims at discovering classes that really want to support the interface of the superclass [29]. In order to understand what are the methods really invoked on subclass instances, they intentionally override these methods introducing an error in the new implementation (e.g., division by zero). If there are classes in the system invoking the method, then a failure will occur. Otherwise, the method is never invoked and an instance of Refused Bequest is found.
\\
\\
\subsection{Code smell detection formulated as an optimization problem:}
%smell-10
\textbf{Kessentini et al. [36] todo, fix copy\&paste }
Kessentini et al. [36] as they presented a technique to detect design de- fects by following the assumption that what significantly diverges from good design practices is likely to represent a design problem. The advantage of their approach is that it does not look for specific code smells (as most ap- proaches) but for design problems in general. Also, in the reported evaluation, the approach was able to achieve a 95\% precision in identifying design defects [36].
\\
\\
%smell-11
\textbf{Kessentini et al. [37] todo, fix copy\&paste }
Kessentini et al. [37] also presented a cooperative parallel search- based approach for identifying code smells instances with an accuracy higher than 85\%.
\\
\\
%smell-12
\textbf{Boussaa et al. [13] todo, fix copy\&paste }
Boussaa et al. [13] proposed the use of competitive coevolutionary search to code-smell detection problem. In their approach two populations evolve simultaneously: the first generates detection rules with the aim of detecting the highest possible proportion of code smells, whereas the second population generates smells that are currently not detected by the rules of the other population.
\\
\\
%smell-13
\textbf{Sahin et al. [68] todo, fix copy\&paste }
Sahin et al. [68] proposed an approach able to generate code smell detection rules using a bi-level optimization problem, in which the first level of optimization task creates a set of detection rules that maximizes the coverage of code smell examples and artificial code smells generated by the second level. The lower level is instead responsible to maximize the number of code smells artificially generated. The empirical evaluation shows that this approach achieves an average of more than 85\% in terms of precision and recall.
\\
\\
%different category
\subsection{Non binary classification (smell/clean)}
The approaches described above classify classes strictly as being clean or anti-patterns, while an accurate analysis for the borderline classes is missing [40] 
\\
\\
%smell-14
\textbf{Khomh et al. [40] todo, fix copy\&paste }
Khomh et al. [40] proposed an approach based on Bayesian belief networks providing a likelihood that a code component is affected by a smell, instead of a boolean value as done by the previous techniques.
\\
\\
%smell-15
\textbf{Oliveto et al. [58] todo, fix copy\&paste }
This is also one of the main characteristics of the approach based on the quality metrics and B-splines proposed by Oliveto et al. [58] for identifying instances of Blobs in source code
\\
\\
%different category
\subsection{Usage of historical data for code smells}
%smell-16
\textbf{Ratiu et al. [65] todo, fix copy\&paste }
Ratiu et al. [65] proposed to use the historical information of the suspected flawed structure to increase the accuracy of the automatic problem detection.
\\
\\
%smell-17
\textbf{Palomba et al. [60] todo, fix copy\&paste }
Palomba et al. [60] provided evidence that historical data can be successfully exploited to identify not only smells that are intrinsically characterized by their evolution across the program history – such as Divergent Change, Parallel Inheritance, and Shotgun Surgery – but also smells such as Blob and Feature Envy [60].
\\
\\